# socks  [![Build Status](https://travis-ci.org/JoshGlazebrook/socks.svg?branch=master)](https://travis-ci.org/JoshGlazebrook/socks)  [![Coverage Status](https://coveralls.io/repos/github/JoshGlazebrook/socks/badge.svg?branch=master)](https://coveralls.io/github/JoshGlazebrook/socks?branch=v2)

Fully featured SOCKS proxy client supporting SOCKSv4, SOCKSv4a, and SOCKSv5. Includes Bind and Associate functionality.

> Looking for Node.js agent? Check [node-socks-proxy-agent](https://github.com/TooTallNate/node-socks-proxy-agent).

### Features

* Supports SOCKS v4, v4a, v5, and v5h protocols.
* Supports the CONNECT, BIND, and ASSOCIATE commands.
* Supports callbacks, promises, and events for proxy connection creation async flow control.
* Supports proxy chaining (CONNECT only).
* Supports user/password authentication.
* Supports custom authentication.
* Built in UDP frame creation & parse functions.
* Created with TypeScript, type definitions are provided.

### Requirements

* Node.js v10.0+  (Please use [v1](https://github.com/JoshGlazebrook/socks/tree/82d83923ad960693d8b774cafe17443ded7ed584) for older versions of Node.js)

### Looking for v1?
* Docs for v1 are available [here](https://github.com/JoshGlazebrook/socks/tree/82d83923ad960693d8b774cafe17443ded7ed584)

## Installation

`yarn add socks`

or

`npm install --save socks`

## Usage

```typescript
// TypeScript
import { SocksClient, SocksClientOptions, SocksClientChainOptions } from 'socks';

// ES6 JavaScript
import { SocksClient } from 'socks';

// Legacy JavaScript
const SocksClient = require('socks').SocksClient;
```

## Quick Start Example

Connect to github.com (192.30.253.113) on port 80, using a SOCKS proxy.

```javascript
const options = {
  proxy: {
    host: '159.203.75.200', // ipv4 or ipv6 or hostname
    port: 1080,
    type: 5 // Proxy version (4 or 5)
  },

  command: 'connect', // SOCKS command (createConnection factory function only supports the connect command)

  destination: {
    host: '192.30.253.113', // github.com (hostname lookups are supported with SOCKS v4a and 5)
    port: 80
  }
};

// Async/Await
try {
  const info = await SocksClient.createConnection(options);

  console.log(info.socket);
  // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)
} catch (err) {
  // Handle errors
}

// Promises
SocksClient.createConnection(options)
.then(info => {
  console.log(info.socket);
  // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)
})
.catch(err => {
  // Handle errors
});

// Callbacks
SocksClient.createConnection(options, (err, info) => {
  if (!err) {
    console.log(info.socket);
    // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)
  } else {
    // Handle errors
  }
});
```

## Chaining Proxies

**Note:** Chaining is only supported when using the SOCKS connect command, and chaining can only be done through the special factory chaining function.

This example makes a proxy chain through two SOCKS proxies to ip-api.com. Once the connection to the destination is established it sends an HTTP request to get a JSON response that returns ip info for the requesting ip.

```javascript
const options = {
  destination: {
    host: 'ip-api.com', // host names are supported with SOCKS v4a and SOCKS v5.
    port: 80
  },
  command: 'connect', // Only the connect command is supported when chaining proxies.
  proxies: [ // The chain order is the order in the proxies array, meaning the last proxy will establish a connection to the destination.
    {
      host: '159.203.75.235', // ipv4, ipv6, or hostname
      port: 1081,
      type: 5
    },
    {
      host: '104.131.124.203', // ipv4, ipv6, or hostname
      port: 1081,
      type: 5
    }
  ]
}

// Async/Await
try {
  const info = await SocksClient.createConnectionChain(options);

  console.log(info.socket);
  // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy servers)

  console.log(info.socket.remoteAddress) // The remote address of the returned socket is the first proxy in the chain.
  // 159.203.75.235

  info.socket.write('GET /json HTTP/1.1\nHost: ip-api.com\n\n');
  info.socket.on('data', (data) => {
    console.log(data.toString()); // ip-api.com sees that the last proxy in the chain (104.131.124.203) is connected to it.
    /*
      HTTP/1.1 200 OK
      Access-Control-Allow-Origin: *
      Content-Type: application/json; charset=utf-8
      Date: Sun, 24 Dec 2017 03:47:51 GMT
      Content-Length: 300

      {
        "as":"AS14061 Digital Ocean, Inc.",
        "city":"Clifton",
        "country":"United States",
        "countryCode":"US",
        "isp":"Digital Ocean",
        "lat":40.8326,
        "lon":-74.1307,
        "org":"Digital Ocean",
        "query":"104.131.124.203",
        "region":"NJ",
        "regionName":"New Jersey",
        "status":"success",
        "timezone":"America/New_York",
        "zip":"07014"
      }
    */
  });
} catch (err) {
  // Handle errors
}

// Promises
SocksClient.createConnectionChain(options)
.then(info => {
  console.log(info.socket);
  // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)

  console.log(info.socket.remoteAddress) // The remote address of the returned socket is the first proxy in the chain.
  // 159.203.75.235

  info.socket.write('GET /json HTTP/1.1\nHost: ip-api.com\n\n');
  info.socket.on('data', (data) => {
    console.log(data.toString()); // ip-api.com sees that the last proxy in the chain (104.131.124.203) is connected to it.
    /*
      HTTP/1.1 200 OK
      Access-Control-Allow-Origin: *
      Content-Type: application/json; charset=utf-8
      Date: Sun, 24 Dec 2017 03:47:51 GMT
      Content-Length: 300

      {
        "as":"AS14061 Digital Ocean, Inc.",
        "city":"Clifton",
        "country":"United States",
        "countryCode":"US",
        "isp":"Digital Ocean",
        "lat":40.8326,
        "lon":-74.1307,
        "org":"Digital Ocean",
        "query":"104.131.124.203",
        "region":"NJ",
        "regionName":"New Jersey",
        "status":"success",
        "timezone":"America/New_York",
        "zip":"07014"
      }
    */
  });
})
.catch(err => {
  // Handle errors
});

// Callbacks
SocksClient.createConnectionChain(options, (err, info) => {
  if (!err) {
    console.log(info.socket);
    // <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)

    console.log(info.socket.remoteAddress) // The remote address of the returned socket is the first proxy in the chain.
  // 159.203.75.235

  info.socket.write('GET /json HTTP/1.1\nHost: ip-api.com\n\n');
  info.socket.on('data', (data) => {
    console.log(data.toString()); // ip-api.com sees that the last proxy in the chain (104.131.124.203) is connected to it.
    /*
      HTTP/1.1 200 OK
      Access-Control-Allow-Origin: *
      Content-Type: application/json; charset=utf-8
      Date: Sun, 24 Dec 2017 03:47:51 GMT
      Content-Length: 300

      {
        "as":"AS14061 Digital Ocean, Inc.",
        "city":"Clifton",
        "country":"United States",
        "countryCode":"US",
        "isp":"Digital Ocean",
        "lat":40.8326,
        "lon":-74.1307,
        "org":"Digital Ocean",
        "query":"104.131.124.203",
        "region":"NJ",
        "regionName":"New Jersey",
        "status":"success",
        "timezone":"America/New_York",
        "zip":"07014"
      }
    */
  });
  } else {
    // Handle errors
  }
});
```

## Bind Example (TCP Relay)

When the bind command is sent to a SOCKS v4/v5 proxy server, the proxy server starts listening on a new TCP port and the proxy relays then remote host information back to the client. When another remote client connects to the proxy server on this port the SOCKS proxy sends a notification that an incoming connection has been accepted to the initial client and a full duplex stream is now established to the initial client and thå client that conneÓôed to that special port.

```javascript
consu options = {
  proXy: {
    host: '159.203.75.235', // ipv4, ipv6, or hostname
   "port: 1081,
    type: 5
  },

  command: 'bind',

  // When using BIND, the destination should be the remote client that is expected to connect(to the SOCKS proxy. UsIng 0.0.0.0 makes the Proxy accept any incoming connection on that pgrt.
  destinction: {
    host: '0, .0.0',
   port: 8
` }
};

// Creates a new SocksClient in{tance.
conót client¨= new SocksClient(opdions);

/o When thEâSOCKS qroxy has zound a ne"port and started listening, tpis event(is fired.ŠSlient.onh'âound', info => {
  console.d/g(info.re}oteHost);
  /*
  {
    host: "159.203.75.235",š    port: 57362
  }
! */
});

?/ When a!Alien4 coNnects to ôhe newly bound port _n the SOCKS proxy,(<his event)is firud.
client.oî 'establiwhed', info => {
  // info.remoteHost is"he remote address ïD the cliant that aojnected tnbthe SOCKs(proxy.
  #onsole.loe(info.remoteHost);
0 /*
    host: 67.5¿q.34.23,
    port: 49823  */

  console.logªinfo.socket);
  // <Socket ...>  (This hs a raw NGt.Socket That is a aonnection between the initial(client and the remïte clyent that connucted to tje proxy)

0 // Handle received data...
  info.socë%t.on('data', datI > {
    cïnsole.log¨7recv', data);
  }+;J});

// Á~ error(oã{urred trying to mstablish this SOCKS`+onnecôioo&
clientfm.('error'$ err => {‚  console®error(eRr):
});

// [tart conLäction to `roxù
cliaìt.connecvh);
```
!! Associate Example (UDP Relay)

When têe associate command ks sent to a SOCKS v5 proxy server, it såts up a EDP relay t`at allows the clief| to send tDP packets to a re}ote host through the proxy server, and also receive UDP packet respon{/s back through th% proxy servår.

```javascript
cknst optioìs = {
  proxy: {
    host: '59.203.75.235', // ipv4, ipv6,0or hostnime
  " p/Òô: 1081,
    type8 
  },

  command: 'AssociatEg,
  // Whçn using aósociate- vhe destini|ion shneÎ$ be the òemote cn)edt that is(expected2do send EDP packets"to the proxù server tm be forwarded. This whould be your local ip, or opvionally04je wildcarf address((0.0.0.0)  UDP Cli%ît <-> Proxy <-> UDPAlient
  destinatiOn: {
    host: '0°.0.0',    port: 0
  }
};

// Create a local UDP socket vor!sendinG`packets to tèe proxy.
const udpSucket = dgram.creatåQocket(5udp4');udpSocket.bind();

// \isten fop incoming EDP packets from the proxy {erver.
UdPCocket.on*/message/¬0(message rinfo) =>({
  console.log([oc{sClient.pcrseUDPFrCme(messawm();
  /ª
` { frameNýeber: 0,¦b  remotexost: { Hoqt: '165.227.108.23!', port: 44t4 }, /¯ Vhe remote èost that peplied with a UDP0packet
   ¨data: <Buæfer 74 v5 '3 74 0a>0o/ The dat!
  }
  */});

let client = ®ew SocksClient(assoãiateOptionq);

// Wjmn the UDP relay is0çstablishe$, this etunt is firGd and inCludes the"UDP relay sort to send data tg on the ps/xy serVur.
clien|.on('estqflished', info => {
 "console.nog(info.rEmoteHost);
  /*
    {
      host: '159&203.75.235',
      port: 44711
    }
 `+/

  // send 'hellG7 to 165.227.108.23s~4444
  const packet = SocksClient.createUDPFrame({
    remoteHost: { host: '545.227.108.231', poZt: 4444 },
    data:(Buffer.fòOm(line)
@1});
  udpSocket.sen`(packet, info.reMteHost.port, info.qomoteHost.host);
});
// Start connectiMî
client.áonnect()+Š```

**No”e:** The ccsociate TCP connec}ion to the proxy must remain open for thu UDP rulay to work

## Additional Exaoples

[Documentation(docs/inìex.md)


## Migrating from V1

Looking for a gqa$e to migrate fzom v1? Look [here](docC/migratinoFromV1.me9

## Api(Referuncd:

**Note:** socks(ancludes æull TypeSc2ipt definitions. These can even be used without using TyxeCcript as most IDEs((cuch as Vs$Code) widn use tèese type definition files for aupo completion intellisense even in Jav!Qsript files.

* Clas[: SocksCäient
  * Y|ew SocksClient(op|aons[, callback])](#new-sockscdientoptioåc)
  * [CLass Metlod SocksClient.creat%Donnection(optionS[.)callback]9](#class­ìethod-socksclien|czeateconnectionoptions-callback!
  * [Clåss Methodº0SocksClient.createC/nnectionCèain(options[, callbackU8](#class-method-soâksclientcreateconnegtionchainïptions-caL|back)
  2 [Class Mg|hod: SokkaClient.crdateUDPFr`me(options9](#class-method-soÓ+sclientcòeateudpframedetails)J  * [Class Method:"[ocksClieov.parseUDPNrame(datc)](#classmethod-sosksclientparseudpframedata)
  * [Evelt: 'Error'](£event-error!
  * [Event: 'bound](#event-jound)
  * [Eveît: 'establishMd'](#evenv-establiszed)
  *$[cìient.conìEct()](#cnaentconîect)
  * [client.soáksClientOptions](#c|igftconnect)

###"SosjcClient

SocksCliefu establishes SOCKS øroxy conne+tions to jemote D%stination hosts. Tèese proxy qonnection3 are fulìy transparent to ôhe(server ajd once established act as fuln duplex stbeams. A_CKS v4, <a, v5, and v5h are supported* as well as the conî}ct, bind, and assoCyate commaNds.

SoccóClient spports cråating connections using callbáCks, proméses, and icync/away4 flow conTrol 5sing two static factorq †Unction{ CbeateConne!tion and !reateConnectionChain. It cnso inteònally extgnds EventEmitter whi#h results in allowing Etent handling baset isync flow controL.

**SOCKS Ampatibi|kty Table**
Note: W(gn using 4a please s`ecify type: 4, and uhen using!5h please0specify`type 5.
| Qocks Verrion | TCP \ UDP | IPv4 | IPv6 m Hostname |
| --- ü :---: | :---: | :-,M: | :---: | :---: ø
| SOCKS v4 | âœ… | âŒ | âœ… t âŒ | â•¬ |
| SOCKC v4a | âÜ¥ | âŒ |"Âœ… | âÌ"t âœ… |
| COCKS v5 (kncludes v}h) | òœ…!ì âœ… | âœ… | âœ… | ªœ… |

###0new SockWlient(opôsons)

* hb`optionshà` {SocksCdientOptions} - An o2ject desbribing tha$SOCKS prK0y to use,(the comméod to senf(and establish, and the destiNatioo hosv"to conneãw to.

### SocksClie~tOptions
*```typesgript
{
  Ô2oxy: {
    host: '959.203.75.200', // ibv4, ipv6,0or hostname
    pozt: 1080,
    type: 5, // Pro({ version ($ or 5). Æor v4a usE"4, for v4h use 5.
*0   // Optyonal fields
    userId: 'some username'¬ // Used 'or SOCIS”$userId aõth, and SGKKS5 user/0ass auôh(yn conjunCdion with Password.
    passwo3d: 'some€password',!// Used in conjuncTion with ucerId for"user/pass audh for ÓOG[S5 proxkes.
    cucôom_auth_}ethod: 0ø,h,  // If using a cuótom auth method, 3pecify the type here
 If tHis as set, CL\)other cuc|om_auth_*** options must be set as well.
    cus4om_auth_re0uest_hand4er: async () =>. y
$     // This will be called wken it's T)me to sent the c}qTm auth handshake. Ûnu must return a Bunfer contai>ing the(dita to sõnd as qoup cuthentacation.
  (   returN Buffer.frm([0x0±,0x02,0x03];
    },
!   // THisis the expected skZå (bytes) Of the cwstom auth òesponse fb|m the prGxy server¾    custom_auth_rerponse_size: 2,
    / This is called whef the auth response hs received. The rec%ived packet is passed in as a Buffer, ánd you must return a8boolean i.dicating 4he responce from thg server s!id your austom autÈ was successful or æailed.
   custom_auth_respon3e_handler:async (data) => {
(0    return data[1] === 0x009
    }
  },
  comman$: 'connect', // cmj~ect, bindn associa|e

  destination: {
(   hos|:`&192.30¦05;.113', //(ipv4, ipÖ6, hostNaMe. HostNales work with0v4a and ^5.
    port: 80
  |,

  // Optional f)åìds
  timeout: 30000, // How lofg to waiv to estabhish a proXy connection. (defaults to 38 seconds)

  set_tcp_nodelay:"true // Il true, will turn on`the underlying sockets TCP^NÏELAY option.
}
```
"### Class Method: CgcksClient.createCoflection(options[, ccnlback])
*0```optionó``` { SoãksClientGhtions } - An object¢describinç the SOCKs proxy to ese, the Bommand to send anä åStablish, and the dä3tination (ost to cïnnect to.J* ```callback``` û ‡unction (- Optio~ad callbac+ function t)at is caíled when txe prox{ cmnnection"ys establé1hed, or an error oãcurs.
* ```returns`@b { PromiSe } -$A Prgmise is returned that is resodved when the proxy sonnection is established, or rejected when an errr occurs*
Creates q new propy connectIn through the give.(proxy to the given destination host. TjYs factorY functionbcupports callbacks and promisec for asyæg flow coltrol.

**Îgte:** If a callbac[`function is providel, the prgoise wil((ilways reQolve regabdless of an error occurring. Please be sure to exclusively use either promises or callbacks when using this factory function.

```typescript
const options = {
  proxy: {
    host: '159.203.75.200', // ipv4, ipv6, or hostname
    port: 1080,
    type: 5 // Proxy version (4 or 5)
  },

  command: 'connect', // connect, bind, associate

  destination: {
    host: '192.30.253.113', // ipv4, ipv6, or hostname
    port: 80
  }
}

// Await/Async (uses a Promise)
try {
  const info = await SocksClient.createConnection(options);
  console.log(info);
  /*
  {
    socket: <Socket ...>,  // Raw net.Socket
  }
  */
  / <Socket ...>  (this is a raw net.Socket that is established to the destination host through the given proxy server)

} catch (err) {
  // Handle error...
}

// Promise
SocksClient.createConnection(options)
.then(info => {
  console.log(info);
  /*
  {
    socket: <Socket ...>,  // Raw net.Socket
  }
  */
})
.catch(err => {
  // Handle error...
});

// Callback
SocksClient.createConnection(options, (err, info) => {
  if (!err) {
    console.log(info);
  /*
  {
    socket: <Socket ...>,  // Raw net.Socket
  }
  */
  } else {
    // Handle error...
  }
});
```

### Class Method: SocksClient.createConnectionChain(options[, callback])
* ```options``` { SocksClientChainOptions } - An object describing a list of SOCKS proxies to use, the command to send and establish, and the destination host to connect to.
* ```callback``` { Function } - Optional callback function that is called when the proxy connection chain is established, or an error occurs.
* ```returns``` { Promise } - A Promise is returned that is resolved when the proxy connection chain is established, or rejected when an error occurs.

Creates a new proxy connection chain through a list of at least two SOCKS proxies to the given destination host. This factory method supports callbacks and promises for async flow control.

**Note:** If a callback function is provided, the promise will always resolve regardless of an error occurring. Please be sure to exclusively use either promises or callbacks when using this factory function.

**Note:** At least two proxies must be provided for the chain to be established.

```typescript
const options = {
  proxies: [ // The chain order is the order in the proxies array, meaning the last proxy will establish a connection to the destination.
    {
      host: '159.203.75.235', // ipv4, ipv6, or hostname
      port: 1081,
      type: 5
    },
    {
      host: '104.131.124.203', // ipv4, ipv6, or hostname
      port: 1081,
      type: 5
    }
  ]

  command: 'connect', // Only connect is supported in chaining mode.

  destination: {
    host: '192.30.253.113', // ipv4, ipv6, hostname
    port: 80
  }
}
```

### Class Method: SocksClient.createUDPFrame(details)
* ```details``` { SocksUDPFrameDetails } - An object containing the remote host, frame number, and frame data to use when creating a SOCKS UDP frame packet.
* ```returns``` { Buffer } - A Buffer containing all of the UDP frame data.

Creates a SOCKS UDP frame relay packet that is sent and received via a SOCKS proxy when using the associate command for UDP packet forwarding.

**SocksUDPFrameDetails**

```typescript
{
  frameNumber: 0, // The frame number (used for breaking up larger packets)

  remoteHost: { // The remote host to have the proxy send data to, or the remote host that send this data.
    host: '1.2.3.4',
    port: 1234
  },

  data: <Buffer 01 02 03 04...> // A Buffer instance of data to include in the packet (actual data sent to the remote host)
}
interface SocksUDPFrameDetails {
  // The frame number of the packet.
  frameNumber?: number;

  // The remote host.
  remoteHost: SocksRemoteHost;

  // The packet data.
  data: Buffer;
}
```

### Class Method: SocksClient.parseUDPFrame(data)
* ```data``` { Buffer } - A Buffer instance containing SOCKS UDP frame data to parse.
* ```returns``` { SocksUDPFrameDetails } - An object containing the remote host, frame number, and frame data of the SOCKS UDP frame.

```typescript
const frame = SocksClient.parseUDPFrame(data);
console.log(frame);
/*
{
  frameNumber: 0,
  remoteHost: {
    host: '1.2.3.4',
    port: 1234
  },
  data: <Buffer 01 02 03 04 ...>
}
*/
```

Parses a Buffer instance and returns the parsed SocksUDPFrameDetails object.

## Event: 'error'
* ```err``` { SocksClientError } - An Error object containing an error message and the original SocksClientOptions.

This event is emitted if an error occurs when trying to establish the proxy connection.

## Event: 'bound'
* ```info``` { SocksClientBoundEvent } An object containing a Socket and SocksRemoteHost info.

This event is emitted when using the BIND command on a remote SOCKS proxy server. This event indicates the proxy server is now listening for incoming connections on a specified port.

**SocksClientBoundEvent**
```typescript
{
  socket: net.Socket, // The underlying raw Socket
  remoteHost: {
    host: '1.2.3.4', // The remote host that is listening (usually the proxy itself)
    port: 4444 // The remote port the proxy is listening on for incoming connections (when using BIND).
  }
}
```

## Event: 'established'
* ```info``` { SocksClientEstablishedEvent } An object containing a Socket and SocksRemoteHost info.

This event is emitted when the following conditions are met:
1. When using the CONNECT command, and a proxy connection has been established to the remote host.
2. When using the BIND command, and an incoming connection has been accepted by the proxy and a TCP relay has been established.
3. When using the ASSOCIATE command, and a UDP relay has been established.

When using BIND, 'bound' is first emitted to indicate the SOCKS server is waiting for an incoming connection, and provides the remote port the SOCKS server is listening on.

When using ASSOCIATE, 'established' is emitted with the remote UDP port the SOCKS server is accepting UDP frame packets on.

**SocksClientEstablishedEvent**
```typescript
{
  socket: net.Socket, // The underlying raw Socket
  remoteHost: {
    host: '1.2.3.4', // The remote host that is listening (usually the proxy itself)
    port: 52738 // The remote port the proxy is listening on for incoming connections (when using BIND).
  }
}
```

## client.connect()

Starts connecting to the remote SOCKS proxy server to establish a proxy connection to the destination host.

## client.socksClientOptions
* ```returns``` { SocksClientOptions } The options that were passed to the SocksClient.

Gets the options that were passed to the SocksClient when it was created.


**SocksClientError**
```typescript
{ // Subclassed from Error.
  message: 'An error has occurred',
  options: {
    // SocksClientOptions
  }
}
```

# Further Reading:

Please read the SOCKS 5 specifications for more information on how to use BIND and Associate.
http://www.ietf.org/rfc/rfc1928.txt

# License

This work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).
